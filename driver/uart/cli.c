/*!
 * \file cli.c
 */
#include "autoconf.h"
#include "string.h"
#include <stdbool.h>
#include <xdc/std.h>
#include <xdc/runtime/Error.h>
#include <xdc/runtime/Assert.h>
#include <ti/sysbios/knl/Task.h>
#include "uart.h"
#include "FreeRTOS_CLI.h"

#if defined(CONFIG_USE_CLI)

#if CONFIG_CLI_IO_UART_A
#define CLI_UART    UART_A
#elif CONFIG_CLI_IO_UART_B
#define CLI_UART    UART_B
#elif CONFIG_CLI_IO_UART_C
#define CLI_UART    UART_C
#endif

static const char * tag = "cli";
static bool bInitDone = false;
static Task_Handle tskHdl_cli = NULL;
static char input_strBuf[CONFIG_CLI_COMMAND_MAX_INPUT_SIZE];
static const char * const welcomeString = "\r\n\n"
        "******************************************************\r\n"
        "* Type 'help' to view a list of registered commands.\r\n"
        "******************************************************\r\n";
static const char * const strLineSep = "\r\n";
static const char * const strPrompt = "$ ";
#if defined( CONFIG_CLI_ECHO_INPUT )
static const char BsDel[] = { 0x08, 0x20, 0x08 };  // known as "Destructive Backspace"
#endif


static Void tsk_command_console(UArg a0, UArg a1);

void CLI_init(void)
{
    Error_Block eb;
    Task_Params tskParam;

    if(bInitDone != true) {
        Error_init(&eb);

        memset(input_strBuf, 0, sizeof(input_strBuf));

        UART_init();

        /*
         * Create Command Console Task
         */
        Task_Params_init(&tskParam);
        tskParam.priority = CONFIG_CLI_TASK_PRIORITY;
        tskParam.stackSize = CONFIG_CLI_TASK_STACK;
        tskParam.instance->name = tag;
        tskHdl_cli = Task_create(tsk_command_console, &tskParam, &eb);
        Assert_isTrue((Error_check(&eb) == FALSE) && (tskHdl_cli != NULL), NULL);

        bInitDone = true;
    }
}


static void helper_send_blocking(Char * pBuf, UInt16 count)
{
    UInt16 actualByteSent = 0;
    Int16 bytesToSend = count;
    UInt16 loopCnt = 0;

    while(loopCnt < 10) {
        actualByteSent = UART_send(CLI_UART, pBuf, bytesToSend);
        pBuf = pBuf + actualByteSent;
        bytesToSend -= actualByteSent;
        if(bytesToSend <= 0) {
            break;
        }
        loopCnt++;
        Task_sleep(100);
    }
}


static Void tsk_command_console(UArg a0, UArg a1)
{
    Int16 inputIndex = 0;
    Int16 moreDataToFollow = 0;
    char * output_str_buf = NULL;
    char rxChar = 0;

    output_str_buf = CLIGetOutputBuffer();

    /* print welcome string */
    helper_send_blocking((char *)welcomeString, strlen(welcomeString));

    /* print prompt symbol */
    helper_send_blocking((char *)strPrompt, 2);

    while(1) {
        if(0 == UART_receive(CLI_UART, &rxChar, 1)) {
            /* Nothing received */
            Task_sleep(10);
        } else {
            /* Accept only ASCII (0x00 - 0x7F) */
            if((rxChar < 0x00) || (rxChar > 0x7F)) {
                continue;
            }

            if(rxChar == '\n') {
                /*
                 * A newline character was received, so the input command string is
                 * complete and can be processed.  Transmit a line separator, just to
                 * make the output easier to read.
                 */
                helper_send_blocking((char *)strLineSep, strlen(strLineSep));
                helper_send_blocking((char *)strLineSep, strlen(strLineSep));

                if(strlen(input_strBuf) == 0) {
                    /* No command to process */
                    /* Just print prompt */
                    helper_send_blocking((char *)strPrompt, 2);
                    continue;
                }

                /*
                 * The command interpreter is called repeatedly until it returns
                 * pdFALSE (0).
                 */
                do {
                    /*
                     * Send the command string to the command interpreter.  Any
                     * output generated by the command interpreter will be placed in the
                     * output_str_buf buffer.
                     */
                    moreDataToFollow = CLIProcessCommand
                                  (
                                      input_strBuf,                         /* The command string.*/
                                      output_str_buf,                       /* The output buffer. */
                                      CONFIG_CLI_COMMAND_MAX_OUTPUT_SIZE    /* The size of the output buffer. */
                                  );

                    /*
                     * Write the output generated by the command interpreter to the
                     * console.
                     */
                    helper_send_blocking(output_str_buf, strlen(output_str_buf));

                } while( moreDataToFollow != 0 );

                /*
                 * All the strings generated by the input command have been sent.
                 * Processing of the command is complete.  Clear the input string ready
                 * to receive the next command.
                 */
                inputIndex = 0;
                memset( input_strBuf, 0x00, sizeof(input_strBuf) );

                /* print prompt symbol */
                helper_send_blocking((char *)strPrompt, 2);
            } else {
                /*
                 * The if() clause performs the processing after a newline character
                 * is received.  This else clause performs the processing if any other
                 * character is received. */
                if( rxChar == '\r' ) {
                    /* Ignore carriage returns. */\

                } else if( rxChar == '\b' ) {
                    /*
                     * Backspace was pressed.  Erase the last character in the input
                     * buffer - if there are any
                     */
                    if( inputIndex > 0 )
                    {
                        inputIndex--;
                        input_strBuf[ inputIndex ] = '\0';
#if defined( CONFIG_CLI_ECHO_INPUT )
                        /* Send destructive backspace */
                        helper_send_blocking((char *)BsDel, 3);
#endif
                    }

                } else {
                    /*
                     * A character was entered.  It was not a new line, backspace
                     * or carriage return, so it is accepted as part of the input and
                     * placed into the input buffer.  When a n is entered the complete
                     * string will be passed to the command interpreter.
                     */
                    if( inputIndex < CONFIG_CLI_COMMAND_MAX_INPUT_SIZE )
                    {
                        input_strBuf[ inputIndex ] = rxChar;
                        inputIndex++;
#if defined( CONFIG_CLI_ECHO_INPUT )
                        helper_send_blocking(&rxChar, 1);
#endif
                    }
                }
            }
        }
    }
}
#endif /* #if defined(CONFIG_USE_CLI) */
